module.exports = {
  "_": "{\n  \"expansions\":\n    A: a. (add a a)\n    B: a. b. (add #(A a) (A b))\n    C: a. b. #(B a b)\n    (eql (C (A 1) (B 1 2)) 16)\n}\n",
  "_a": "| sub: <(fork [\"A dog\", \"A ninja\", \"Donald Trump\"]),\n  vrb: <(fork [\"has eaten\", \"attacked\", \"has fired\"])\n  obj: <(fork [\"my homework\", \"the enemy\", \"the director\"])\n  [(arrayJoin \" \" [sub, vrb, obj])]\n",
  "_b": "80\n",
  "_c": "lisA: (listMap (mul 0.001) (listRange 0 1000))\nlisB: (listMap (mul 0.001) (listRange 0 1000))\n(for 0 2 0 i. x.\n  (add x (listDot lisA lisB)))\n",
  "_d": "a: (arrayRange 0 10)\nb: (arrayRange 0 10)\n(arrayJoin \"-\" [\"aff\", \"bff\", \"cff\"])\n",
  "_e": "len: 10000\narrA: (arrayMap (mul 0.001) (arrayRange 0 len))\narrB: (arrayMap (mul 0.001) (arrayRange 0 len))\n(for 0 len 0 #i. x.\n  (add x (arrayDot arrA arrB)))\n",
  "_f": "(arraySum (arrayRange 1 10))\n",
  "arrayConcat": "a. b.\n  aLen: (arrayLength a)\n  bLen: (arrayLength b)\n  cLen: (add aLen bLen)\n  (arrayGenerate 0 cLen i.\n    (if (ltn i aLen)\n      (arrayGet a i)\n      (arrayGet b (sub i aLen))))\n",
  "arrayDot": "a. b.\n  (arraySum\n    (arrayZipWith (mul) a b))\n",
  "arrayFlatMap": "fn. array. (arrayFlatten (arrayMap fn array))\n",
  "arrayFlatten": "(arrayFoldr arrayConcat [])\n",
  "arrayFoldl": "snoc. \n  (arrayIfoldl r.i.(snoc r))\n",
  "arrayFoldr": "cons.\n  (arrayIfoldr i.cons)\n",
  "arrayGenerate": "from. til. fn.\n  (gen c. n.\n    kvs: (listRange from til h.(c (nts h) (fn h)) n)\n    (c \"length\" (sub til from) kvs))\n",
  "arrayGet": "array. i.\n  (get array (nts i))\n",
  "arrayIfoldl": "snoc. nil. array.\n  len: (get array \"length\")\n  (for 0 len nil i.result.\n    (snoc result i (arrayGet array i)))\n",
  "arrayIfoldr": "cons. nil. array.\n  len: (arrayLength array)\n  (for 0 len nil i. result.\n    idx: (sub (sub len i) 1)\n    val: (arrayGet array idx)\n    (cons idx val result))\n",
  "arrayJoin": "separator.\n  (arrayIfoldr\n    i. a. b.\n      sep: (if (eql i 0) \"\" separator)\n      (con (con sep a) b)\n    \"\")\n",
  "arrayLength": "array.\n  (get array \"length\")\n",
  "arrayMap": "fn. array.\n  len: (arrayLength array)\n  (arrayGenerate 0 len i.\n    (fn (arrayGet array i)))\n",
  "arrayRange": "from. til.\n  (gen c. n.\n    kvs: (listRange from til i.(c (nts (sub i from)) i) n)\n    (c \"length\" (sub til from) kvs))\n",
  "arraySum": "(arrayFoldr (add) 0)\n",
  "arrayToList": "array. cons. nil. \n  (arrayFoldr cons nil array)\n",
  "arrayZipWith": "fn. xs. ys.\n  len: \"length\"\n  (gen c.n.\n    lim: (get xs len)\n    ini: (c len lim n)\n    (for 0 lim ini i.a.\n      k: (nts i)\n      g: a.(get a k)\n      (c k (fn (g xs) (g ys)) a)))\n\n",
  "dot": "# ax. ay. az. bx. by. bz.\n  (arraySum (arrayZipWith (mul)\n    [ax, ay, az]\n    [bx, by, bz]))\n",
  "flip": "f. a. b.\n  (f b a)\n",
  "fork": " (flip arrayFlatMap)\n",
  "ioBind": "a. b.\n  ioFree. ioPure.\n    (a ioFree \n      x. (b x ioFree ioPure))\n",
  "ioExit": "ioExitM\n",
  "ioExitF": "ioGetLineF. ioPutLineF. ioExitF.\n  ioExitF\n",
  "ioExitM": "ioFree. ioPure.\n  (ioFree ioExitF)\n",
  "ioExitT": "ioGetLineT. ioPutLineT. ioExitT.\n  ioExitT\n",
  "ioFree": "t.\n  ioFree. ioPure.\n    (t\n      cont. (ioFree (ioGetLineF str.(cont str ioPure ioFree)))\n      str. cont. (ioFree (ioPutLineF str (cont ioPure ioFree)))\n      (ioFree ioExitT))\n",
  "ioGetLine": "(ioBind ioGetLineM)\n",
  "ioGetLineF": "cont.\n  ioGetLineF. ioPutLineFT. ioExitFT.\n    (ioGetLineF cont)\n",
  "ioGetLineM": "ioFree. ioPure.\n  (ioFree (ioGetLineF x.(ioPure x)))\n",
  "ioGetLineT": "cont.\n  ioGetLineT. ioPutLineT. ioExitT.\n    (ioGetLineT line.(cont line ioGetLineT ioPutLineT ioExitT))\n",
  "ioProgram": "p.\n  ioGetLineT. ioPutLineT. ioExitT.\n    caseGetLineT: cont. (ioGetLineT cont)\n    casePutLineT: str. cont. (ioPutLineT str cont)\n    caseExitT: ioExitT\n    (p t.(t caseGetLineT casePutLineT caseExitT) x.ioExitT)\n",
  "ioPure": "x.\n  ioFree. ioPure.\n    (ioPure x)\n",
  "ioPutLine": "s. (ioBind (ioPutLineM s))\n",
  "ioPutLineF": "str. cont.\n  ioGetLineF. ioPutLineF. ioExitFT.\n    (ioPutLineF str cont)\n",
  "ioPutLineM": "s. ioFree. ioPure.\n  (ioFree (ioPutLineF s (ioPure {})))\n",
  "ioPutLineT": "str. cont.\n  ioGetLineT. ioPutLineT. ioExitT.\n    (ioPutLineT str (cont ioGetLineT ioPutLineT ioExitT))\n",
  "listConcat": "xs. ys.\n  cons. nil. (xs cons (ys cons nil))\n",
  "listCons": "head. tail.\n  cons. nil. (cons head (tail cons nil))\n",
  "listDot": "# a. b.\n  (listSum\n    (listZipWith (mul) a b))\n",
  "listFilter": "f. xs.\n  cons. (xs x.xs. (if (f x) (cons x xs) xs))\n",
  "listFlatten": "xs.\n  (xs listConcat listNil)\n",
  "listFoldr": "cons. nil. list.\n  (list cons nil)\n",
  "listMap": "f. xs.\n  cons. (xs head.(cons (f head)))\n",
  "listNil": "cons. nil. nil\n",
  "listRange": "from. til. cons. nil.\n  (for from til nil i.\n    (cons (sub (add from til) (add i 1))))\n",
  "listReverse": "list.\n  (list h.t.c.n.(t c (c h n)) c.n.n)",
  "listSum": "xs. (xs (add) 0)\n",
  "listToArray": "list.\n  (gen c. n. (list\n    h.t.i.(c (nts i) h (t (add i 1)))\n    i.(c \"length\" i n)\n    0))\n",
  "listZipWith": "f. xs. ys.\n  cons. nil.\n    (xs x.xs.c.(c x xs) c.nil\n    (ys y.xs.x.c.(cons (f x y) (c xs)) x.c.nil))\n",
  "test": "{\n  \"a\": (arraySum [1,2,3,4])\n\n  \"b\":\n    mulOf: m. n. (eql (mod n m) 0)\n    valid: n. (add (mulOf 3 n) (mulOf 5 n))\n    (with (listRange 0 1000) [\n      (listFilter valid)\n      listSum\n    ])\n\n  \"c\": |\n    sub: <(fork [\"A dog\", \"A ninja\"]),\n    vrb: <(fork [\"has eaten\", \"attacked\"])\n    obj: <(fork [\"my homework\", \"the enemy\"])\n    [(arrayJoin \" \" [sub, vrb, obj])]\n\n  \"d\": \n    dot: ax. ay. az. bx. by. bz.\n      (listSum\n        (listZipWith x.y.(mul x y)\n          (arrayToList [ax,ay,az])\n          (arrayToList [bx,by,bz])))\n\n    (dot 4 0 0 4 0 0)\n}\n",
  "with": "target.\n  (arrayFoldl\n    result. action.\n      (action result)\n    target)\n"
}
