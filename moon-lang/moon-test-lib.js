module.exports = {
  "n0": "s. z. z",
  "n1": "s. z. (s z)",
  "n2": "s. z. (s (s z))",
  "n3": "s. z. (s (s (s z)))",
  "n4": "s. z. (s (s (s (s z))))",
  "nAdd": "a. b. c. n. (a c (b c n))",
  "nMul": "a. b. c. (a (b c) n)",
  "nExp": "a. b. (b b)",
  "listToArray": "list.(gen c.n.(list h.t.i.(c (nts i) h (t (add i 1))) i.(c \"length\" i n)\n 0))\n",
  "_": "{\n  \"expansions\":\n    A: a. (add a a)\n    B: a. b. (add #(A a) (A b))\n    C: a. b. #(B a b)\n    (eql (C (A 1) (B 1 2)) 16)\n}\n",
  "_a": "| sub: <(fork [\"A dog\", \"A ninja\", \"Donald Trump\"]),\n  vrb: <(fork [\"has eaten\", \"attacked\", \"has fired\"])\n  obj: <(fork [\"my homework\", \"the enemy\", \"the director\"])\n  [(arrayJoin \" \" [sub, vrb, obj])]\n",
  "_b": "80\n",
  "_c": "lisA: (listMap (mul 0.001) (listRange 0 1000))\nlisB: (listMap (mul 0.001) (listRange 0 1000))\n(for 0 2 0 i. x.\n  (add x (listDot lisA lisB)))\n",
  "_d": "a: (arrayRange 0 10)\nb: (arrayRange 0 10)\n(arrayJoin \"-\" [\"aff\", \"bff\", \"cff\"])\n",
  "_e": "len: 10000\narrA: (arrayMap (mul 0.001) (arrayRange 0 len))\narrB: (arrayMap (mul 0.001) (arrayRange 0 len))\n(for 0 len 0 #i. x.\n  (add x (arrayDot arrA arrB)))\n",
  "_f": "(arraySum (arrayRange 1 10))\n",
  "arrayConcat": "a. b.\n  aLen: (arrayLength a)\n  bLen: (arrayLength b)\n  cLen: (add aLen bLen)\n  (arrayGenerate 0 cLen i.\n    (if (ltn i aLen)\n      (arrayGet a i)\n      (arrayGet b (sub i aLen))))\n",
  "arrayDot": "a. b.\n  (arraySum\n    (arrayZipWith (mul) a b))\n",
  "arrayFlatMap": "fn. array. (arrayFlatten (arrayMap fn array))\n",
  "arrayFlatten": "(arrayFoldr arrayConcat [])\n",
  "arrayFoldl": "snoc. \n  (arrayIfoldl r.i.(snoc r))\n",
  "arrayFoldr": "cons.\n  (arrayIfoldr i.cons)\n",
  "arrayGenerate": "from. til. fn.\n  (gen c. n.\n    kvs: (listRange from til h.(c (nts h) (fn h)) n)\n    (c \"length\" (sub til from) kvs))\n",
  "arrayGet": "array. i.\n  (get array (nts i))\n",
  "arrayIfoldl": "snoc. nil. array.\n  len: (get array \"length\")\n  (for 0 len nil i.result.\n    (snoc result i (arrayGet array i)))\n",
  "arrayIfoldr": "cons. nil. array.\n  len: (arrayLength array)\n  (for 0 len nil i. result.\n    idx: (sub (sub len i) 1)\n    val: (arrayGet array idx)\n    (cons idx val result))\n",
  "arrayJoin": "separator.\n  (arrayIfoldr\n    i. a. b.\n      sep: (if (eql i 0) \"\" separator)\n      (con (con sep a) b)\n    \"\")\n",
  "arrayLength": "array.\n  (get array \"length\")\n",
  "arrayMap": "fn. array.\n  len: (arrayLength array)\n  (arrayGenerate 0 len i.\n    (fn (arrayGet array i)))\n",
  "arrayRange": "from. til.\n  (gen c. n.\n    kvs: (listRange from til i.(c (nts (sub i from)) i) n)\n    (c \"length\" (sub til from) kvs))\n",
  "arraySum": "(arrayFoldr (add) 0)\n",
  "arrayToList": "array. cons. nil. \n  (arrayFoldr cons nil array)\n",
  "arrayZipWith": "fn. xs. ys.\n  len: \"length\"\n  (gen c.n.\n    lim: (get xs len)\n    ini: (c len lim n)\n    (for 0 lim ini i.a.\n      k: (nts i)\n      g: a.(get a k)\n      (c k (fn (g xs) (g ys)) a)))\n\n",
  "dot": "# ax. ay. az. bx. by. bz.\n  (arraySum (arrayZipWith (mul)\n    [ax, ay, az]\n    [bx, by, bz]))\n",
  "flip": "f. a. b.\n  (f b a)\n",
  "fork": " (flip arrayFlatMap)\n",
  "listConcat": "xs. ys.\n  cons. nil. (xs cons (ys cons nil))\n",
  "listCons": "head. tail.\n  cons. nil. (cons head (tail cons nil))\n",
  "listDot": "# a. b.\n  (listSum\n    (listZipWith (mul) a b))\n",
  "listFilter": "f. xs.\n  cons. (xs x.xs. (if (f x) (cons x xs) xs))\n",
  "listFlatten": "xs.\n  (xs listConcat listNil)\n",
  "listFoldr": "cons. nil. list.\n  (list cons nil)\n",
  "listMap": "f. xs.\n  cons. (xs head.(cons (f head)))\n",
  "listNil": "cons. nil. nil\n",
  "listRange": "from. til. cons. nil.\n  (for from til nil i.\n    (cons (sub (add from til) (add i 1))))\n",
  "listReverse": "list.\n  (list h.t.c.n.(t c (c h n)) c.n.n)",
  "listSum": "xs. (xs (add) 0)\n",
  "listToArray": "list.(gen c.n.(list h.t.i.(c (nts i) h (t (add i 1))) i.(c \"length\" i n)\n 0))\n",
  "listZipWith": "f. xs. ys.\n  cons. nil.\n    (xs x.xs.c.(c x xs) c.nil\n    (ys y.xs.x.c.(cons (f x y) (c xs)) x.c.nil))\n",
  "with": "target.\n  (arrayFoldl\n    result. action.\n      (action result)\n    target)\n"
};
